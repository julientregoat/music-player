- to get the rust - swift FFI working
  - add the built dylib to xcode [build phases > link binary with libraries]
  - create bridging header to include all ext headers
  - set objective c bridging header path
  - add the dylib path (should be rust proj root /target/debug) to the ld search
  paths in [Build Settings > SearchPaths > Header Search Paths]. this is akin to
  passing the `-L<lib dir>` flag to `ld` or setting `LD_LIBRARY_PATHS`
- an alternative to the FFI option is to have a rust binary listening on a socket
and returning data as requested
- run postgres in docker when deploying to user?
- searching for tracks - use postgres full text search.
  - create a GIN index on all columns, maybe on a column that has an autogenerated ts_vector to query against. see https://www.postgresql.org/docs/12/textsearch-tables.html for more
- ensure that data only stored in the release struct (e.g. date) triggers
an update of metadata for all tracks in that release
- batch inserts - to save on time when importing releases? is it worth it?
can set ON CONFLICT DO NOTHING and use RETURNING (id), and diff the ids input
and output or something like that to check what didnt get inseretd. may not be effective
to ensure the order of operations
